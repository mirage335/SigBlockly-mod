diff --git a/build.py b/build.py
index 98d105c..18c9d22 100755
--- a/build.py
+++ b/build.py
@@ -207,6 +207,7 @@ class Gen_compressed(threading.Thread):
 
     if ('generators' in self.bundles):
       self.gen_generator("javascript")
+      self.gen_generator("bash")
       self.gen_generator("python")
       self.gen_generator("php")
       self.gen_generator("lua")
diff --git a/demos/code/code.js b/demos/code/code.js
index ed1d520..dcd29b2 100644
--- a/demos/code/code.js
+++ b/demos/code/code.js
@@ -238,7 +238,7 @@ Code.LANG = Code.getLang();
  * List of tab names.
  * @private
  */
-Code.TABS_ = ['blocks', 'javascript', 'php', 'python', 'dart', 'lua', 'xml'];
+Code.TABS_ = ['blocks', 'javascript', 'bash', 'php', 'python', 'dart', 'lua', 'xml'];
 
 Code.selected = 'blocks';
 
@@ -305,6 +305,8 @@ Code.renderContent = function() {
     xmlTextarea.focus();
   } else if (content.id == 'content_javascript') {
     Code.attemptCodeGeneration(Blockly.JavaScript, 'js');
+  } else if (content.id == 'content_bash') {
+    Code.attemptCodeGeneration(Blockly.bash, 'bash');
   } else if (content.id == 'content_python') {
     Code.attemptCodeGeneration(Blockly.Python, 'py');
   } else if (content.id == 'content_php') {
diff --git a/demos/code/index.html b/demos/code/index.html
index 3210db5..5ac0179 100644
--- a/demos/code/index.html
+++ b/demos/code/index.html
@@ -9,6 +9,7 @@
   <script src="../../blockly_compressed.js"></script>
   <script src="../../blocks_compressed.js"></script>
   <script src="../../javascript_compressed.js"></script>
+  <script src="../../bash_compressed.js"></script>
   <script src="../../python_compressed.js"></script>
   <script src="../../php_compressed.js"></script>
   <script src="../../lua_compressed.js"></script>
@@ -36,6 +37,8 @@
             <td class="tabmin">&nbsp;</td>
             <td id="tab_javascript" class="taboff">JavaScript</td>
             <td class="tabmin">&nbsp;</td>
+            <td id="tab_bash" class="taboff">BASH</td>
+            <td class="tabmin">&nbsp;</td>
             <td id="tab_python" class="taboff">Python</td>
             <td class="tabmin">&nbsp;</td>
             <td id="tab_php" class="taboff">PHP</td>
@@ -67,6 +70,7 @@
   </table>
   <div id="content_blocks" class="content"></div>
   <pre id="content_javascript" class="content"></pre>
+  <pre id="content_bash" class="content"></pre>
   <pre id="content_python" class="content"></pre>
   <pre id="content_php" class="content"></pre>
   <pre id="content_lua" class="content"></pre>
diff --git a/generators/bash.js b/generators/bash.js
index 347a41c..98243f7 100644
--- a/generators/bash.js
+++ b/generators/bash.js
@@ -24,7 +24,7 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python');
+goog.provide('Blockly.bash');
 
 goog.require('Blockly.Generator');
 
@@ -33,7 +33,7 @@ goog.require('Blockly.Generator');
  * Python code generator.
  * @type {!Blockly.Generator}
  */
-Blockly.Python = new Blockly.Generator('Python');
+Blockly.bash = new Blockly.Generator('bash');
 
 /**
  * List of illegal variable names.
@@ -42,7 +42,7 @@ Blockly.Python = new Blockly.Generator('Python');
  * accidentally clobbering a built-in object or function.
  * @private
  */
-Blockly.Python.addReservedWords(
+Blockly.bash.addReservedWords(
     // import keyword
     // print(','.join(sorted(keyword.kwlist)))
     // https://docs.python.org/3/reference/lexical_analysis.html#keywords
@@ -88,96 +88,96 @@ Blockly.Python.addReservedWords(
  * Order of operation ENUMs.
  * http://docs.python.org/reference/expressions.html#summary
  */
-Blockly.Python.ORDER_ATOMIC = 0;            // 0 "" ...
-Blockly.Python.ORDER_COLLECTION = 1;        // tuples, lists, dictionaries
-Blockly.Python.ORDER_STRING_CONVERSION = 1; // `expression...`
-Blockly.Python.ORDER_MEMBER = 2.1;          // . []
-Blockly.Python.ORDER_FUNCTION_CALL = 2.2;   // ()
-Blockly.Python.ORDER_EXPONENTIATION = 3;    // **
-Blockly.Python.ORDER_UNARY_SIGN = 4;        // + -
-Blockly.Python.ORDER_BITWISE_NOT = 4;       // ~
-Blockly.Python.ORDER_MULTIPLICATIVE = 5;    // * / // %
-Blockly.Python.ORDER_ADDITIVE = 6;          // + -
-Blockly.Python.ORDER_BITWISE_SHIFT = 7;     // << >>
-Blockly.Python.ORDER_BITWISE_AND = 8;       // &
-Blockly.Python.ORDER_BITWISE_XOR = 9;       // ^
-Blockly.Python.ORDER_BITWISE_OR = 10;       // |
-Blockly.Python.ORDER_RELATIONAL = 11;       // in, not in, is, is not,
+Blockly.bash.ORDER_ATOMIC = 0;            // 0 "" ...
+Blockly.bash.ORDER_COLLECTION = 1;        // tuples, lists, dictionaries
+Blockly.bash.ORDER_STRING_CONVERSION = 1; // `expression...`
+Blockly.bash.ORDER_MEMBER = 2.1;          // . []
+Blockly.bash.ORDER_FUNCTION_CALL = 2.2;   // ()
+Blockly.bash.ORDER_EXPONENTIATION = 3;    // **
+Blockly.bash.ORDER_UNARY_SIGN = 4;        // + -
+Blockly.bash.ORDER_BITWISE_NOT = 4;       // ~
+Blockly.bash.ORDER_MULTIPLICATIVE = 5;    // * / // %
+Blockly.bash.ORDER_ADDITIVE = 6;          // + -
+Blockly.bash.ORDER_BITWISE_SHIFT = 7;     // << >>
+Blockly.bash.ORDER_BITWISE_AND = 8;       // &
+Blockly.bash.ORDER_BITWISE_XOR = 9;       // ^
+Blockly.bash.ORDER_BITWISE_OR = 10;       // |
+Blockly.bash.ORDER_RELATIONAL = 11;       // in, not in, is, is not,
                                             //     <, <=, >, >=, <>, !=, ==
-Blockly.Python.ORDER_LOGICAL_NOT = 12;      // not
-Blockly.Python.ORDER_LOGICAL_AND = 13;      // and
-Blockly.Python.ORDER_LOGICAL_OR = 14;       // or
-Blockly.Python.ORDER_CONDITIONAL = 15;      // if else
-Blockly.Python.ORDER_LAMBDA = 16;           // lambda
-Blockly.Python.ORDER_NONE = 99;             // (...)
+Blockly.bash.ORDER_LOGICAL_NOT = 12;      // not
+Blockly.bash.ORDER_LOGICAL_AND = 13;      // and
+Blockly.bash.ORDER_LOGICAL_OR = 14;       // or
+Blockly.bash.ORDER_CONDITIONAL = 15;      // if else
+Blockly.bash.ORDER_LAMBDA = 16;           // lambda
+Blockly.bash.ORDER_NONE = 99;             // (...)
 
 /**
  * List of outer-inner pairings that do NOT require parentheses.
  * @type {!Array.<!Array.<number>>}
  */
-Blockly.Python.ORDER_OVERRIDES = [
+Blockly.bash.ORDER_OVERRIDES = [
   // (foo()).bar -> foo().bar
   // (foo())[0] -> foo()[0]
-  [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_MEMBER],
+  [Blockly.bash.ORDER_FUNCTION_CALL, Blockly.bash.ORDER_MEMBER],
   // (foo())() -> foo()()
-  [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_FUNCTION_CALL],
+  [Blockly.bash.ORDER_FUNCTION_CALL, Blockly.bash.ORDER_FUNCTION_CALL],
   // (foo.bar).baz -> foo.bar.baz
   // (foo.bar)[0] -> foo.bar[0]
   // (foo[0]).bar -> foo[0].bar
   // (foo[0])[1] -> foo[0][1]
-  [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_MEMBER],
+  [Blockly.bash.ORDER_MEMBER, Blockly.bash.ORDER_MEMBER],
   // (foo.bar)() -> foo.bar()
   // (foo[0])() -> foo[0]()
-  [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_FUNCTION_CALL],
+  [Blockly.bash.ORDER_MEMBER, Blockly.bash.ORDER_FUNCTION_CALL],
 
   // not (not foo) -> not not foo
-  [Blockly.Python.ORDER_LOGICAL_NOT, Blockly.Python.ORDER_LOGICAL_NOT],
+  [Blockly.bash.ORDER_LOGICAL_NOT, Blockly.bash.ORDER_LOGICAL_NOT],
   // a and (b and c) -> a and b and c
-  [Blockly.Python.ORDER_LOGICAL_AND, Blockly.Python.ORDER_LOGICAL_AND],
+  [Blockly.bash.ORDER_LOGICAL_AND, Blockly.bash.ORDER_LOGICAL_AND],
   // a or (b or c) -> a or b or c
-  [Blockly.Python.ORDER_LOGICAL_OR, Blockly.Python.ORDER_LOGICAL_OR]
+  [Blockly.bash.ORDER_LOGICAL_OR, Blockly.bash.ORDER_LOGICAL_OR]
 ];
 
 /**
  * Initialise the database of variable names.
  * @param {!Blockly.Workspace} workspace Workspace to generate code from.
  */
-Blockly.Python.init = function(workspace) {
+Blockly.bash.init = function(workspace) {
   /**
    * Empty loops or conditionals are not allowed in Python.
    */
-  Blockly.Python.PASS = this.INDENT + 'pass\n';
+  Blockly.bash.PASS = this.INDENT + 'pass\n';
   // Create a dictionary of definitions to be printed before the code.
-  Blockly.Python.definitions_ = Object.create(null);
+  Blockly.bash.definitions_ = Object.create(null);
   // Create a dictionary mapping desired function names in definitions_
   // to actual function names (to avoid collisions with user functions).
-  Blockly.Python.functionNames_ = Object.create(null);
+  Blockly.bash.functionNames_ = Object.create(null);
 
-  if (!Blockly.Python.variableDB_) {
-    Blockly.Python.variableDB_ =
-        new Blockly.Names(Blockly.Python.RESERVED_WORDS_);
+  if (!Blockly.bash.variableDB_) {
+    Blockly.bash.variableDB_ =
+        new Blockly.Names(Blockly.bash.RESERVED_WORDS_);
   } else {
-    Blockly.Python.variableDB_.reset();
+    Blockly.bash.variableDB_.reset();
   }
 
-  Blockly.Python.variableDB_.setVariableMap(workspace.getVariableMap());
+  Blockly.bash.variableDB_.setVariableMap(workspace.getVariableMap());
 
   var defvars = [];
   // Add developer variables (not created or named by the user).
   var devVarList = Blockly.Variables.allDeveloperVariables(workspace);
   for (var i = 0; i < devVarList.length; i++) {
-    defvars.push(Blockly.Python.variableDB_.getName(devVarList[i],
+    defvars.push(Blockly.bash.variableDB_.getName(devVarList[i],
         Blockly.Names.DEVELOPER_VARIABLE_TYPE) + ' = None');
   }
 
   // Add user variables, but only ones that are being used.
   var variables = Blockly.Variables.allUsedVarModels(workspace);
   for (var i = 0; i < variables.length; i++) {
-    defvars.push(Blockly.Python.variableDB_.getName(variables[i].getId(),
+    defvars.push(Blockly.bash.variableDB_.getName(variables[i].getId(),
         Blockly.Variables.NAME_TYPE) + ' = None');
   }
 
-  Blockly.Python.definitions_['variables'] = defvars.join('\n');
+  Blockly.bash.definitions_['variables'] = defvars.join('\n');
 };
 
 /**
@@ -185,12 +185,12 @@ Blockly.Python.init = function(workspace) {
  * @param {string} code Generated code.
  * @return {string} Completed code.
  */
-Blockly.Python.finish = function(code) {
+Blockly.bash.finish = function(code) {
   // Convert the definitions dictionary into a list.
   var imports = [];
   var definitions = [];
-  for (var name in Blockly.Python.definitions_) {
-    var def = Blockly.Python.definitions_[name];
+  for (var name in Blockly.bash.definitions_) {
+    var def = Blockly.bash.definitions_[name];
     if (def.match(/^(from\s+\S+\s+)?import\s+\S+/)) {
       imports.push(def);
     } else {
@@ -198,9 +198,9 @@ Blockly.Python.finish = function(code) {
     }
   }
   // Clean up temporary data.
-  delete Blockly.Python.definitions_;
-  delete Blockly.Python.functionNames_;
-  Blockly.Python.variableDB_.reset();
+  delete Blockly.bash.definitions_;
+  delete Blockly.bash.functionNames_;
+  Blockly.bash.variableDB_.reset();
   var allDefs = imports.join('\n') + '\n\n' + definitions.join('\n\n');
   return allDefs.replace(/\n\n+/g, '\n\n').replace(/\n*$/, '\n\n\n') + code;
 };
@@ -211,7 +211,7 @@ Blockly.Python.finish = function(code) {
  * @param {string} line Line of generated code.
  * @return {string} Legal line of code.
  */
-Blockly.Python.scrubNakedValue = function(line) {
+Blockly.bash.scrubNakedValue = function(line) {
   return line + '\n';
 };
 
@@ -221,7 +221,7 @@ Blockly.Python.scrubNakedValue = function(line) {
  * @return {string} Python string.
  * @private
  */
-Blockly.Python.quote_ = function(string) {
+Blockly.bash.quote_ = function(string) {
   // Can't use goog.string.quote since % must also be escaped.
   string = string.replace(/\\/g, '\\\\')
                  .replace(/\n/g, '\\\n')
@@ -248,19 +248,19 @@ Blockly.Python.quote_ = function(string) {
  * @return {string} Python code with comments and subsequent blocks added.
  * @private
  */
-Blockly.Python.scrub_ = function(block, code) {
+Blockly.bash.scrub_ = function(block, code) {
   var commentCode = '';
   // Only collect comments for blocks that aren't inline.
   if (!block.outputConnection || !block.outputConnection.targetConnection) {
     // Collect comment for this block.
     var comment = block.getCommentText();
-    comment = Blockly.utils.wrap(comment, Blockly.Python.COMMENT_WRAP - 3);
+    comment = Blockly.utils.wrap(comment, Blockly.bash.COMMENT_WRAP - 3);
     if (comment) {
       if (block.getProcedureDef) {
         // Use a comment block for function comments.
         commentCode += '"""' + comment + '\n"""\n';
       } else {
-        commentCode += Blockly.Python.prefixLines(comment + '\n', '# ');
+        commentCode += Blockly.bash.prefixLines(comment + '\n', '# ');
       }
     }
     // Collect comments for all value arguments.
@@ -269,16 +269,16 @@ Blockly.Python.scrub_ = function(block, code) {
       if (block.inputList[i].type == Blockly.INPUT_VALUE) {
         var childBlock = block.inputList[i].connection.targetBlock();
         if (childBlock) {
-          var comment = Blockly.Python.allNestedComments(childBlock);
+          var comment = Blockly.bash.allNestedComments(childBlock);
           if (comment) {
-            commentCode += Blockly.Python.prefixLines(comment, '# ');
+            commentCode += Blockly.bash.prefixLines(comment, '# ');
           }
         }
       }
     }
   }
   var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
-  var nextCode = Blockly.Python.blockToCode(nextBlock);
+  var nextCode = Blockly.bash.blockToCode(nextBlock);
   return commentCode + code + nextCode;
 };
 
@@ -291,15 +291,15 @@ Blockly.Python.scrub_ = function(block, code) {
  * @param {boolean=} opt_negate Whether to negate the value.
  * @return {string|number}
  */
-Blockly.Python.getAdjustedInt = function(block, atId, opt_delta, opt_negate) {
+Blockly.bash.getAdjustedInt = function(block, atId, opt_delta, opt_negate) {
   var delta = opt_delta || 0;
   if (block.workspace.options.oneBasedIndex) {
     delta--;
   }
   var defaultAtIndex = block.workspace.options.oneBasedIndex ? '1' : '0';
-  var atOrder = delta ? Blockly.Python.ORDER_ADDITIVE :
-      Blockly.Python.ORDER_NONE;
-  var at = Blockly.Python.valueToCode(block, atId, atOrder) || defaultAtIndex;
+  var atOrder = delta ? Blockly.bash.ORDER_ADDITIVE :
+      Blockly.bash.ORDER_NONE;
+  var at = Blockly.bash.valueToCode(block, atId, atOrder) || defaultAtIndex;
 
   if (Blockly.isNumber(at)) {
     // If the index is a naked number, adjust it right now.
diff --git a/generators/bash/colour.js b/generators/bash/colour.js
index 68666a8..a689ceb 100644
--- a/generators/bash/colour.js
+++ b/generators/bash/colour.js
@@ -24,48 +24,48 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.colour');
+goog.provide('Blockly.bash.colour');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['colour_picker'] = function(block) {
+Blockly.bash['colour_picker'] = function(block) {
   // Colour picker.
   var code = '\'' + block.getFieldValue('COLOUR') + '\'';
-  return [code, Blockly.Python.ORDER_ATOMIC];
+  return [code, Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['colour_random'] = function(block) {
+Blockly.bash['colour_random'] = function(block) {
   // Generate a random colour.
-  Blockly.Python.definitions_['import_random'] = 'import random';
+  Blockly.bash.definitions_['import_random'] = 'import random';
   var code = '\'#%06x\' % random.randint(0, 2**24 - 1)';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['colour_rgb'] = function(block) {
+Blockly.bash['colour_rgb'] = function(block) {
   // Compose a colour from RGB components expressed as percentages.
-  var functionName = Blockly.Python.provideFunction_(
+  var functionName = Blockly.bash.provideFunction_(
       'colour_rgb',
-      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(r, g, b):',
+      ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(r, g, b):',
        '  r = round(min(100, max(0, r)) * 2.55)',
        '  g = round(min(100, max(0, g)) * 2.55)',
        '  b = round(min(100, max(0, b)) * 2.55)',
        '  return \'#%02x%02x%02x\' % (r, g, b)']);
-  var r = Blockly.Python.valueToCode(block, 'RED',
-                                     Blockly.Python.ORDER_NONE) || 0;
-  var g = Blockly.Python.valueToCode(block, 'GREEN',
-                                     Blockly.Python.ORDER_NONE) || 0;
-  var b = Blockly.Python.valueToCode(block, 'BLUE',
-                                     Blockly.Python.ORDER_NONE) || 0;
+  var r = Blockly.bash.valueToCode(block, 'RED',
+                                     Blockly.bash.ORDER_NONE) || 0;
+  var g = Blockly.bash.valueToCode(block, 'GREEN',
+                                     Blockly.bash.ORDER_NONE) || 0;
+  var b = Blockly.bash.valueToCode(block, 'BLUE',
+                                     Blockly.bash.ORDER_NONE) || 0;
   var code = functionName + '(' + r + ', ' + g + ', ' + b + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['colour_blend'] = function(block) {
+Blockly.bash['colour_blend'] = function(block) {
   // Blend two colours together.
-  var functionName = Blockly.Python.provideFunction_(
+  var functionName = Blockly.bash.provideFunction_(
       'colour_blend',
-      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +
+      ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ +
           '(colour1, colour2, ratio):',
        '  r1, r2 = int(colour1[1:3], 16), int(colour2[1:3], 16)',
        '  g1, g2 = int(colour1[3:5], 16), int(colour2[3:5], 16)',
@@ -75,12 +75,12 @@ Blockly.Python['colour_blend'] = function(block) {
        '  g = round(g1 * (1 - ratio) + g2 * ratio)',
        '  b = round(b1 * (1 - ratio) + b2 * ratio)',
        '  return \'#%02x%02x%02x\' % (r, g, b)']);
-  var colour1 = Blockly.Python.valueToCode(block, 'COLOUR1',
-      Blockly.Python.ORDER_NONE) || '\'#000000\'';
-  var colour2 = Blockly.Python.valueToCode(block, 'COLOUR2',
-      Blockly.Python.ORDER_NONE) || '\'#000000\'';
-  var ratio = Blockly.Python.valueToCode(block, 'RATIO',
-      Blockly.Python.ORDER_NONE) || 0;
+  var colour1 = Blockly.bash.valueToCode(block, 'COLOUR1',
+      Blockly.bash.ORDER_NONE) || '\'#000000\'';
+  var colour2 = Blockly.bash.valueToCode(block, 'COLOUR2',
+      Blockly.bash.ORDER_NONE) || '\'#000000\'';
+  var ratio = Blockly.bash.valueToCode(block, 'RATIO',
+      Blockly.bash.ORDER_NONE) || 0;
   var code = functionName + '(' + colour1 + ', ' + colour2 + ', ' + ratio + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
diff --git a/generators/bash/lists.js b/generators/bash/lists.js
index 3d29acf..942bb4c 100644
--- a/generators/bash/lists.js
+++ b/generators/bash/lists.js
@@ -24,58 +24,58 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.lists');
+goog.provide('Blockly.bash.lists');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['lists_create_empty'] = function(block) {
+Blockly.bash['lists_create_empty'] = function(block) {
   // Create an empty list.
-  return ['[]', Blockly.Python.ORDER_ATOMIC];
+  return ['[]', Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['lists_create_with'] = function(block) {
+Blockly.bash['lists_create_with'] = function(block) {
   // Create a list with any number of elements of any type.
   var elements = new Array(block.itemCount_);
   for (var i = 0; i < block.itemCount_; i++) {
-    elements[i] = Blockly.Python.valueToCode(block, 'ADD' + i,
-        Blockly.Python.ORDER_NONE) || 'None';
+    elements[i] = Blockly.bash.valueToCode(block, 'ADD' + i,
+        Blockly.bash.ORDER_NONE) || 'None';
   }
   var code = '[' + elements.join(', ') + ']';
-  return [code, Blockly.Python.ORDER_ATOMIC];
+  return [code, Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['lists_repeat'] = function(block) {
+Blockly.bash['lists_repeat'] = function(block) {
   // Create a list with one element repeated.
-  var item = Blockly.Python.valueToCode(block, 'ITEM',
-      Blockly.Python.ORDER_NONE) || 'None';
-  var times = Blockly.Python.valueToCode(block, 'NUM',
-      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';
+  var item = Blockly.bash.valueToCode(block, 'ITEM',
+      Blockly.bash.ORDER_NONE) || 'None';
+  var times = Blockly.bash.valueToCode(block, 'NUM',
+      Blockly.bash.ORDER_MULTIPLICATIVE) || '0';
   var code = '[' + item + '] * ' + times;
-  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];
+  return [code, Blockly.bash.ORDER_MULTIPLICATIVE];
 };
 
-Blockly.Python['lists_length'] = function(block) {
+Blockly.bash['lists_length'] = function(block) {
   // String or array length.
-  var list = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '[]';
-  return ['len(' + list + ')', Blockly.Python.ORDER_FUNCTION_CALL];
+  var list = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '[]';
+  return ['len(' + list + ')', Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['lists_isEmpty'] = function(block) {
+Blockly.bash['lists_isEmpty'] = function(block) {
   // Is the string null or array empty?
-  var list = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '[]';
   var code = 'not len(' + list + ')';
-  return [code, Blockly.Python.ORDER_LOGICAL_NOT];
+  return [code, Blockly.bash.ORDER_LOGICAL_NOT];
 };
 
-Blockly.Python['lists_indexOf'] = function(block) {
+Blockly.bash['lists_indexOf'] = function(block) {
   // Find an item in the list.
-  var item = Blockly.Python.valueToCode(block, 'FIND',
-      Blockly.Python.ORDER_NONE) || '[]';
-  var list = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+  var item = Blockly.bash.valueToCode(block, 'FIND',
+      Blockly.bash.ORDER_NONE) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   if (block.workspace.options.oneBasedIndex) {
     var errorIndex = ' 0';
     var firstIndexAdjustment = ' + 1';
@@ -86,44 +86,44 @@ Blockly.Python['lists_indexOf'] = function(block) {
     var lastIndexAdjustment = ' - 1';
   }
   if (block.getFieldValue('END') == 'FIRST') {
-    var functionName = Blockly.Python.provideFunction_(
+    var functionName = Blockly.bash.provideFunction_(
         'first_index',
-        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +
+        ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ +
             '(my_list, elem):',
          '  try: index = my_list.index(elem)' + firstIndexAdjustment,
          '  except: index =' + errorIndex,
          '  return index']);
     var code = functionName + '(' + list + ', ' + item + ')';
-    return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+    return [code, Blockly.bash.ORDER_FUNCTION_CALL];
   }
-  var functionName = Blockly.Python.provideFunction_(
+  var functionName = Blockly.bash.provideFunction_(
       'last_index',
-      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(my_list, elem):',
+      ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(my_list, elem):',
        '  try: index = len(my_list) - my_list[::-1].index(elem)' +
          lastIndexAdjustment,
        '  except: index =' + errorIndex,
        '  return index']);
   var code = functionName + '(' + list + ', ' + item + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['lists_getIndex'] = function(block) {
+Blockly.bash['lists_getIndex'] = function(block) {
   // Get element at index.
   // Note: Until January 2013 this block did not have MODE or WHERE inputs.
   var mode = block.getFieldValue('MODE') || 'GET';
   var where = block.getFieldValue('WHERE') || 'FROM_START';
-  var listOrder = (where == 'RANDOM') ? Blockly.Python.ORDER_NONE :
-      Blockly.Python.ORDER_MEMBER;
-  var list = Blockly.Python.valueToCode(block, 'VALUE', listOrder) || '[]';
+  var listOrder = (where == 'RANDOM') ? Blockly.bash.ORDER_NONE :
+      Blockly.bash.ORDER_MEMBER;
+  var list = Blockly.bash.valueToCode(block, 'VALUE', listOrder) || '[]';
 
   switch (where) {
     case 'FIRST':
       if (mode == 'GET') {
         var code = list + '[0]';
-        return [code, Blockly.Python.ORDER_MEMBER];
+        return [code, Blockly.bash.ORDER_MEMBER];
       } else if (mode == 'GET_REMOVE') {
         var code = list + '.pop(0)';
-        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+        return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       } else if (mode == 'REMOVE') {
         return list + '.pop(0)\n';
       }
@@ -131,52 +131,52 @@ Blockly.Python['lists_getIndex'] = function(block) {
     case 'LAST':
       if (mode == 'GET') {
         var code = list + '[-1]';
-        return [code, Blockly.Python.ORDER_MEMBER];
+        return [code, Blockly.bash.ORDER_MEMBER];
       } else if (mode == 'GET_REMOVE') {
         var code = list + '.pop()';
-        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+        return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       } else if (mode == 'REMOVE') {
         return list + '.pop()\n';
       }
       break;
     case 'FROM_START':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT');
+      var at = Blockly.bash.getAdjustedInt(block, 'AT');
       if (mode == 'GET') {
         var code = list + '[' + at + ']';
-        return [code, Blockly.Python.ORDER_MEMBER];
+        return [code, Blockly.bash.ORDER_MEMBER];
       } else if (mode == 'GET_REMOVE') {
         var code = list + '.pop(' + at + ')';
-        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+        return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       } else if (mode == 'REMOVE') {
         return list + '.pop(' + at + ')\n';
       }
       break;
     case'FROM_END':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT', 1, true);
+      var at = Blockly.bash.getAdjustedInt(block, 'AT', 1, true);
       if (mode == 'GET') {
         var code = list + '[' + at + ']';
-        return [code, Blockly.Python.ORDER_MEMBER];
+        return [code, Blockly.bash.ORDER_MEMBER];
       } else if (mode == 'GET_REMOVE') {
         var code = list + '.pop(' + at + ')';
-        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+        return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       } else if (mode == 'REMOVE') {
         return list + '.pop(' + at + ')\n';
       }
       break;
     case 'RANDOM':
-      Blockly.Python.definitions_['import_random'] = 'import random';
+      Blockly.bash.definitions_['import_random'] = 'import random';
       if (mode == 'GET') {
         code = 'random.choice(' + list + ')';
-        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+        return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       } else {
-        var functionName = Blockly.Python.provideFunction_(
+        var functionName = Blockly.bash.provideFunction_(
             'lists_remove_random_item',
-            ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
+            ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
               '  x = int(random.random() * len(myList))',
               '  return myList.pop(x)']);
         code = functionName + '(' + list + ')';
         if (mode == 'GET_REMOVE') {
-          return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+          return [code, Blockly.bash.ORDER_FUNCTION_CALL];
         } else if (mode == 'REMOVE') {
           return code + '\n';
         }
@@ -186,22 +186,22 @@ Blockly.Python['lists_getIndex'] = function(block) {
   throw 'Unhandled combination (lists_getIndex).';
 };
 
-Blockly.Python['lists_setIndex'] = function(block) {
+Blockly.bash['lists_setIndex'] = function(block) {
   // Set element at index.
   // Note: Until February 2013 this block did not have MODE or WHERE inputs.
-  var list = Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_MEMBER) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_MEMBER) || '[]';
   var mode = block.getFieldValue('MODE') || 'GET';
   var where = block.getFieldValue('WHERE') || 'FROM_START';
-  var value = Blockly.Python.valueToCode(block, 'TO',
-      Blockly.Python.ORDER_NONE) || 'None';
+  var value = Blockly.bash.valueToCode(block, 'TO',
+      Blockly.bash.ORDER_NONE) || 'None';
   // Cache non-trivial values to variables to prevent repeated look-ups.
   // Closure, which accesses and modifies 'list'.
   function cacheList() {
     if (list.match(/^\w+$/)) {
       return '';
     }
-    var listVar = Blockly.Python.variableDB_.getDistinctName(
+    var listVar = Blockly.bash.variableDB_.getDistinctName(
         'tmp_list', Blockly.Variables.NAME_TYPE);
     var code = listVar + ' = ' + list + '\n';
     list = listVar;
@@ -224,7 +224,7 @@ Blockly.Python['lists_setIndex'] = function(block) {
         }
       break;
     case 'FROM_START':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT');
+      var at = Blockly.bash.getAdjustedInt(block, 'AT');
         if (mode == 'SET') {
           return list + '[' + at + '] = ' + value + '\n';
         } else if (mode == 'INSERT') {
@@ -232,7 +232,7 @@ Blockly.Python['lists_setIndex'] = function(block) {
         }
       break;
     case 'FROM_END':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT', 1, true);
+      var at = Blockly.bash.getAdjustedInt(block, 'AT', 1, true);
         if (mode == 'SET') {
           return list + '[' + at + '] = ' + value + '\n';
         } else if (mode == 'INSERT') {
@@ -240,9 +240,9 @@ Blockly.Python['lists_setIndex'] = function(block) {
         }
       break;
     case 'RANDOM':
-        Blockly.Python.definitions_['import_random'] = 'import random';
+        Blockly.bash.definitions_['import_random'] = 'import random';
         var code = cacheList();
-        var xVar = Blockly.Python.variableDB_.getDistinctName(
+        var xVar = Blockly.bash.variableDB_.getDistinctName(
             'tmp_x', Blockly.Variables.NAME_TYPE);
         code += xVar + ' = int(random.random() * len(' + list + '))\n';
         if (mode == 'SET') {
@@ -257,21 +257,21 @@ Blockly.Python['lists_setIndex'] = function(block) {
   throw 'Unhandled combination (lists_setIndex).';
 };
 
-Blockly.Python['lists_getSublist'] = function(block) {
+Blockly.bash['lists_getSublist'] = function(block) {
   // Get sublist.
-  var list = Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_MEMBER) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_MEMBER) || '[]';
   var where1 = block.getFieldValue('WHERE1');
   var where2 = block.getFieldValue('WHERE2');
   switch (where1) {
     case 'FROM_START':
-      var at1 = Blockly.Python.getAdjustedInt(block, 'AT1');
+      var at1 = Blockly.bash.getAdjustedInt(block, 'AT1');
       if (at1 == '0') {
         at1 = '';
       }
       break;
     case 'FROM_END':
-      var at1 = Blockly.Python.getAdjustedInt(block, 'AT1', 1, true);
+      var at1 = Blockly.bash.getAdjustedInt(block, 'AT1', 1, true);
       break;
     case 'FIRST':
       var at1 = '';
@@ -281,14 +281,14 @@ Blockly.Python['lists_getSublist'] = function(block) {
   }
   switch (where2) {
     case 'FROM_START':
-      var at2 = Blockly.Python.getAdjustedInt(block, 'AT2', 1);
+      var at2 = Blockly.bash.getAdjustedInt(block, 'AT2', 1);
       break;
     case 'FROM_END':
-      var at2 = Blockly.Python.getAdjustedInt(block, 'AT2', 0, true);
+      var at2 = Blockly.bash.getAdjustedInt(block, 'AT2', 0, true);
       // Ensure that if the result calculated is 0 that sub-sequence will
       // include all elements as expected.
       if (!Blockly.isNumber(String(at2))) {
-        Blockly.Python.definitions_['import_sys'] = 'import sys';
+        Blockly.bash.definitions_['import_sys'] = 'import sys';
         at2 += ' or sys.maxsize';
       } else if (at2 == '0') {
         at2 = '';
@@ -301,17 +301,17 @@ Blockly.Python['lists_getSublist'] = function(block) {
       throw 'Unhandled option (lists_getSublist)';
   }
   var code = list + '[' + at1 + ' : ' + at2 + ']';
-  return [code, Blockly.Python.ORDER_MEMBER];
+  return [code, Blockly.bash.ORDER_MEMBER];
 };
 
-Blockly.Python['lists_sort'] = function(block) {
+Blockly.bash['lists_sort'] = function(block) {
   // Block for sorting a list.
-  var list = (Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_NONE) || '[]');
+  var list = (Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_NONE) || '[]');
   var type = block.getFieldValue('TYPE');
   var reverse = block.getFieldValue('DIRECTION') === '1' ? 'False' : 'True';
-  var sortFunctionName = Blockly.Python.provideFunction_('lists_sort',
-  ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +
+  var sortFunctionName = Blockly.bash.provideFunction_('lists_sort',
+  ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ +
       '(my_list, type, reverse):',
     '  def try_float(s):',
     '    try:',
@@ -330,34 +330,34 @@ Blockly.Python['lists_sort'] = function(block) {
 
   var code = sortFunctionName +
       '(' + list + ', "' + type + '", ' + reverse + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['lists_split'] = function(block) {
+Blockly.bash['lists_split'] = function(block) {
   // Block for splitting text into a list, or joining a list into text.
   var mode = block.getFieldValue('MODE');
   if (mode == 'SPLIT') {
-    var value_input = Blockly.Python.valueToCode(block, 'INPUT',
-        Blockly.Python.ORDER_MEMBER) || '\'\'';
-    var value_delim = Blockly.Python.valueToCode(block, 'DELIM',
-        Blockly.Python.ORDER_NONE);
+    var value_input = Blockly.bash.valueToCode(block, 'INPUT',
+        Blockly.bash.ORDER_MEMBER) || '\'\'';
+    var value_delim = Blockly.bash.valueToCode(block, 'DELIM',
+        Blockly.bash.ORDER_NONE);
     var code = value_input + '.split(' + value_delim + ')';
   } else if (mode == 'JOIN') {
-    var value_input = Blockly.Python.valueToCode(block, 'INPUT',
-        Blockly.Python.ORDER_NONE) || '[]';
-    var value_delim = Blockly.Python.valueToCode(block, 'DELIM',
-        Blockly.Python.ORDER_MEMBER) || '\'\'';
+    var value_input = Blockly.bash.valueToCode(block, 'INPUT',
+        Blockly.bash.ORDER_NONE) || '[]';
+    var value_delim = Blockly.bash.valueToCode(block, 'DELIM',
+        Blockly.bash.ORDER_MEMBER) || '\'\'';
     var code = value_delim + '.join(' + value_input + ')';
   } else {
     throw 'Unknown mode: ' + mode;
   }
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['lists_reverse'] = function(block) {
+Blockly.bash['lists_reverse'] = function(block) {
   // Block for reversing a list.
-  var list = Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_NONE) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_NONE) || '[]';
   var code = 'list(reversed(' + list + '))';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
diff --git a/generators/bash/logic.js b/generators/bash/logic.js
index fe03648..99ac191 100644
--- a/generators/bash/logic.js
+++ b/generators/bash/logic.js
@@ -24,36 +24,36 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.logic');
+goog.provide('Blockly.bash.logic');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['controls_if'] = function(block) {
+Blockly.bash['controls_if'] = function(block) {
   // If/elseif/else condition.
   var n = 0;
   var code = '', branchCode, conditionCode;
   do {
-    conditionCode = Blockly.Python.valueToCode(block, 'IF' + n,
-        Blockly.Python.ORDER_NONE) || 'False';
-    branchCode = Blockly.Python.statementToCode(block, 'DO' + n) ||
-        Blockly.Python.PASS;
+    conditionCode = Blockly.bash.valueToCode(block, 'IF' + n,
+        Blockly.bash.ORDER_NONE) || 'False';
+    branchCode = Blockly.bash.statementToCode(block, 'DO' + n) ||
+        Blockly.bash.PASS;
     code += (n == 0 ? 'if ' : 'elif ' ) + conditionCode + ':\n' + branchCode;
 
     ++n;
   } while (block.getInput('IF' + n));
 
   if (block.getInput('ELSE')) {
-    branchCode = Blockly.Python.statementToCode(block, 'ELSE') ||
-        Blockly.Python.PASS;
+    branchCode = Blockly.bash.statementToCode(block, 'ELSE') ||
+        Blockly.bash.PASS;
     code += 'else:\n' + branchCode;
   }
   return code;
 };
 
-Blockly.Python['controls_ifelse'] = Blockly.Python['controls_if'];
+Blockly.bash['controls_ifelse'] = Blockly.bash['controls_if'];
 
-Blockly.Python['logic_compare'] = function(block) {
+Blockly.bash['logic_compare'] = function(block) {
   // Comparison operator.
   var OPERATORS = {
     'EQ': '==',
@@ -64,20 +64,20 @@ Blockly.Python['logic_compare'] = function(block) {
     'GTE': '>='
   };
   var operator = OPERATORS[block.getFieldValue('OP')];
-  var order = Blockly.Python.ORDER_RELATIONAL;
-  var argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';
+  var order = Blockly.bash.ORDER_RELATIONAL;
+  var argument0 = Blockly.bash.valueToCode(block, 'A', order) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'B', order) || '0';
   var code = argument0 + ' ' + operator + ' ' + argument1;
   return [code, order];
 };
 
-Blockly.Python['logic_operation'] = function(block) {
+Blockly.bash['logic_operation'] = function(block) {
   // Operations 'and', 'or'.
   var operator = (block.getFieldValue('OP') == 'AND') ? 'and' : 'or';
-  var order = (operator == 'and') ? Blockly.Python.ORDER_LOGICAL_AND :
-      Blockly.Python.ORDER_LOGICAL_OR;
-  var argument0 = Blockly.Python.valueToCode(block, 'A', order);
-  var argument1 = Blockly.Python.valueToCode(block, 'B', order);
+  var order = (operator == 'and') ? Blockly.bash.ORDER_LOGICAL_AND :
+      Blockly.bash.ORDER_LOGICAL_OR;
+  var argument0 = Blockly.bash.valueToCode(block, 'A', order);
+  var argument1 = Blockly.bash.valueToCode(block, 'B', order);
   if (!argument0 && !argument1) {
     // If there are no arguments, then the return value is false.
     argument0 = 'False';
@@ -96,33 +96,33 @@ Blockly.Python['logic_operation'] = function(block) {
   return [code, order];
 };
 
-Blockly.Python['logic_negate'] = function(block) {
+Blockly.bash['logic_negate'] = function(block) {
   // Negation.
-  var argument0 = Blockly.Python.valueToCode(block, 'BOOL',
-      Blockly.Python.ORDER_LOGICAL_NOT) || 'True';
+  var argument0 = Blockly.bash.valueToCode(block, 'BOOL',
+      Blockly.bash.ORDER_LOGICAL_NOT) || 'True';
   var code = 'not ' + argument0;
-  return [code, Blockly.Python.ORDER_LOGICAL_NOT];
+  return [code, Blockly.bash.ORDER_LOGICAL_NOT];
 };
 
-Blockly.Python['logic_boolean'] = function(block) {
+Blockly.bash['logic_boolean'] = function(block) {
   // Boolean values true and false.
   var code = (block.getFieldValue('BOOL') == 'TRUE') ? 'True' : 'False';
-  return [code, Blockly.Python.ORDER_ATOMIC];
+  return [code, Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['logic_null'] = function(block) {
+Blockly.bash['logic_null'] = function(block) {
   // Null data type.
-  return ['None', Blockly.Python.ORDER_ATOMIC];
+  return ['None', Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['logic_ternary'] = function(block) {
+Blockly.bash['logic_ternary'] = function(block) {
   // Ternary operator.
-  var value_if = Blockly.Python.valueToCode(block, 'IF',
-      Blockly.Python.ORDER_CONDITIONAL) || 'False';
-  var value_then = Blockly.Python.valueToCode(block, 'THEN',
-      Blockly.Python.ORDER_CONDITIONAL) || 'None';
-  var value_else = Blockly.Python.valueToCode(block, 'ELSE',
-      Blockly.Python.ORDER_CONDITIONAL) || 'None';
+  var value_if = Blockly.bash.valueToCode(block, 'IF',
+      Blockly.bash.ORDER_CONDITIONAL) || 'False';
+  var value_then = Blockly.bash.valueToCode(block, 'THEN',
+      Blockly.bash.ORDER_CONDITIONAL) || 'None';
+  var value_else = Blockly.bash.valueToCode(block, 'ELSE',
+      Blockly.bash.ORDER_CONDITIONAL) || 'None';
   var code = value_then + ' if ' + value_if + ' else ' + value_else;
-  return [code, Blockly.Python.ORDER_CONDITIONAL];
+  return [code, Blockly.bash.ORDER_CONDITIONAL];
 };
diff --git a/generators/bash/loops.js b/generators/bash/loops.js
index 3cb1ab9..552c081 100644
--- a/generators/bash/loops.js
+++ b/generators/bash/loops.js
@@ -24,83 +24,83 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.loops');
+goog.provide('Blockly.bash.loops');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['controls_repeat_ext'] = function(block) {
+Blockly.bash['controls_repeat_ext'] = function(block) {
   // Repeat n times.
   if (block.getField('TIMES')) {
     // Internal number.
     var repeats = String(parseInt(block.getFieldValue('TIMES'), 10));
   } else {
     // External number.
-    var repeats = Blockly.Python.valueToCode(block, 'TIMES',
-        Blockly.Python.ORDER_NONE) || '0';
+    var repeats = Blockly.bash.valueToCode(block, 'TIMES',
+        Blockly.bash.ORDER_NONE) || '0';
   }
   if (Blockly.isNumber(repeats)) {
     repeats = parseInt(repeats, 10);
   } else {
     repeats = 'int(' + repeats + ')';
   }
-  var branch = Blockly.Python.statementToCode(block, 'DO');
-  branch = Blockly.Python.addLoopTrap(branch, block.id) ||
-      Blockly.Python.PASS;
-  var loopVar = Blockly.Python.variableDB_.getDistinctName(
+  var branch = Blockly.bash.statementToCode(block, 'DO');
+  branch = Blockly.bash.addLoopTrap(branch, block.id) ||
+      Blockly.bash.PASS;
+  var loopVar = Blockly.bash.variableDB_.getDistinctName(
       'count', Blockly.Variables.NAME_TYPE);
   var code = 'for ' + loopVar + ' in range(' + repeats + '):\n' + branch;
   return code;
 };
 
-Blockly.Python['controls_repeat'] = Blockly.Python['controls_repeat_ext'];
+Blockly.bash['controls_repeat'] = Blockly.bash['controls_repeat_ext'];
 
-Blockly.Python['controls_whileUntil'] = function(block) {
+Blockly.bash['controls_whileUntil'] = function(block) {
   // Do while/until loop.
   var until = block.getFieldValue('MODE') == 'UNTIL';
-  var argument0 = Blockly.Python.valueToCode(block, 'BOOL',
-      until ? Blockly.Python.ORDER_LOGICAL_NOT :
-      Blockly.Python.ORDER_NONE) || 'False';
-  var branch = Blockly.Python.statementToCode(block, 'DO');
-  branch = Blockly.Python.addLoopTrap(branch, block.id) ||
-      Blockly.Python.PASS;
+  var argument0 = Blockly.bash.valueToCode(block, 'BOOL',
+      until ? Blockly.bash.ORDER_LOGICAL_NOT :
+      Blockly.bash.ORDER_NONE) || 'False';
+  var branch = Blockly.bash.statementToCode(block, 'DO');
+  branch = Blockly.bash.addLoopTrap(branch, block.id) ||
+      Blockly.bash.PASS;
   if (until) {
     argument0 = 'not ' + argument0;
   }
   return 'while ' + argument0 + ':\n' + branch;
 };
 
-Blockly.Python['controls_for'] = function(block) {
+Blockly.bash['controls_for'] = function(block) {
   // For loop.
-  var variable0 = Blockly.Python.variableDB_.getName(
+  var variable0 = Blockly.bash.variableDB_.getName(
       block.getFieldValue('VAR'), Blockly.Variables.NAME_TYPE);
-  var argument0 = Blockly.Python.valueToCode(block, 'FROM',
-      Blockly.Python.ORDER_NONE) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'TO',
-      Blockly.Python.ORDER_NONE) || '0';
-  var increment = Blockly.Python.valueToCode(block, 'BY',
-      Blockly.Python.ORDER_NONE) || '1';
-  var branch = Blockly.Python.statementToCode(block, 'DO');
-  branch = Blockly.Python.addLoopTrap(branch, block.id) ||
-      Blockly.Python.PASS;
+  var argument0 = Blockly.bash.valueToCode(block, 'FROM',
+      Blockly.bash.ORDER_NONE) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'TO',
+      Blockly.bash.ORDER_NONE) || '0';
+  var increment = Blockly.bash.valueToCode(block, 'BY',
+      Blockly.bash.ORDER_NONE) || '1';
+  var branch = Blockly.bash.statementToCode(block, 'DO');
+  branch = Blockly.bash.addLoopTrap(branch, block.id) ||
+      Blockly.bash.PASS;
 
   var code = '';
   var range;
 
   // Helper functions.
   var defineUpRange = function() {
-    return Blockly.Python.provideFunction_(
+    return Blockly.bash.provideFunction_(
         'upRange',
-        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +
+        ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ +
             '(start, stop, step):',
          '  while start <= stop:',
          '    yield start',
          '    start += abs(step)']);
   };
   var defineDownRange = function() {
-    return Blockly.Python.provideFunction_(
+    return Blockly.bash.provideFunction_(
         'downRange',
-        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ +
+        ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ +
             '(start, stop, step):',
          '  while start >= stop:',
          '    yield start',
@@ -160,7 +160,7 @@ Blockly.Python['controls_for'] = function(block) {
         arg = 'float(' + arg + ')';
       } else {
         // It's complicated.
-        var varName = Blockly.Python.variableDB_.getDistinctName(
+        var varName = Blockly.bash.variableDB_.getDistinctName(
             variable0 + suffix, Blockly.Variables.NAME_TYPE);
         code += varName + ' = float(' + arg + ')\n';
         arg = varName;
@@ -186,20 +186,20 @@ Blockly.Python['controls_for'] = function(block) {
   return code;
 };
 
-Blockly.Python['controls_forEach'] = function(block) {
+Blockly.bash['controls_forEach'] = function(block) {
   // For each loop.
-  var variable0 = Blockly.Python.variableDB_.getName(
+  var variable0 = Blockly.bash.variableDB_.getName(
       block.getFieldValue('VAR'), Blockly.Variables.NAME_TYPE);
-  var argument0 = Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_RELATIONAL) || '[]';
-  var branch = Blockly.Python.statementToCode(block, 'DO');
-  branch = Blockly.Python.addLoopTrap(branch, block.id) ||
-      Blockly.Python.PASS;
+  var argument0 = Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_RELATIONAL) || '[]';
+  var branch = Blockly.bash.statementToCode(block, 'DO');
+  branch = Blockly.bash.addLoopTrap(branch, block.id) ||
+      Blockly.bash.PASS;
   var code = 'for ' + variable0 + ' in ' + argument0 + ':\n' + branch;
   return code;
 };
 
-Blockly.Python['controls_flow_statements'] = function(block) {
+Blockly.bash['controls_flow_statements'] = function(block) {
   // Flow statements: continue, break.
   switch (block.getFieldValue('FLOW')) {
     case 'BREAK':
diff --git a/generators/bash/math.js b/generators/bash/math.js
index a2595e0..6710efb 100644
--- a/generators/bash/math.js
+++ b/generators/bash/math.js
@@ -24,45 +24,45 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.math');
+goog.provide('Blockly.bash.math');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
 // If any new block imports any library, add that library name here.
-Blockly.Python.addReservedWords('math,random,Number');
+Blockly.bash.addReservedWords('math,random,Number');
 
-Blockly.Python['math_number'] = function(block) {
+Blockly.bash['math_number'] = function(block) {
   // Numeric value.
   var code = parseFloat(block.getFieldValue('NUM'));
   var order;
   if (code == Infinity) {
     code = 'float("inf")';
-    order = Blockly.Python.ORDER_FUNCTION_CALL;
+    order = Blockly.bash.ORDER_FUNCTION_CALL;
   } else if (code == -Infinity) {
     code = '-float("inf")';
-    order = Blockly.Python.ORDER_UNARY_SIGN;
+    order = Blockly.bash.ORDER_UNARY_SIGN;
   } else {
-    order = code < 0 ? Blockly.Python.ORDER_UNARY_SIGN :
-            Blockly.Python.ORDER_ATOMIC;
+    order = code < 0 ? Blockly.bash.ORDER_UNARY_SIGN :
+            Blockly.bash.ORDER_ATOMIC;
   }
   return [code, order];
 };
 
-Blockly.Python['math_arithmetic'] = function(block) {
+Blockly.bash['math_arithmetic'] = function(block) {
   // Basic arithmetic operators, and power.
   var OPERATORS = {
-    'ADD': [' + ', Blockly.Python.ORDER_ADDITIVE],
-    'MINUS': [' - ', Blockly.Python.ORDER_ADDITIVE],
-    'MULTIPLY': [' * ', Blockly.Python.ORDER_MULTIPLICATIVE],
-    'DIVIDE': [' / ', Blockly.Python.ORDER_MULTIPLICATIVE],
-    'POWER': [' ** ', Blockly.Python.ORDER_EXPONENTIATION]
+    'ADD': [' + ', Blockly.bash.ORDER_ADDITIVE],
+    'MINUS': [' - ', Blockly.bash.ORDER_ADDITIVE],
+    'MULTIPLY': [' * ', Blockly.bash.ORDER_MULTIPLICATIVE],
+    'DIVIDE': [' / ', Blockly.bash.ORDER_MULTIPLICATIVE],
+    'POWER': [' ** ', Blockly.bash.ORDER_EXPONENTIATION]
   };
   var tuple = OPERATORS[block.getFieldValue('OP')];
   var operator = tuple[0];
   var order = tuple[1];
-  var argument0 = Blockly.Python.valueToCode(block, 'A', order) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'B', order) || '0';
+  var argument0 = Blockly.bash.valueToCode(block, 'A', order) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'B', order) || '0';
   var code = argument0 + operator + argument1;
   return [code, order];
   // In case of 'DIVIDE', division between integers returns different results
@@ -72,24 +72,24 @@ Blockly.Python['math_arithmetic'] = function(block) {
   // legibility of the generated code.
 };
 
-Blockly.Python['math_single'] = function(block) {
+Blockly.bash['math_single'] = function(block) {
   // Math operators with single operand.
   var operator = block.getFieldValue('OP');
   var code;
   var arg;
   if (operator == 'NEG') {
     // Negation is a special case given its different operator precedence.
-    var code = Blockly.Python.valueToCode(block, 'NUM',
-        Blockly.Python.ORDER_UNARY_SIGN) || '0';
-    return ['-' + code, Blockly.Python.ORDER_UNARY_SIGN];
+    var code = Blockly.bash.valueToCode(block, 'NUM',
+        Blockly.bash.ORDER_UNARY_SIGN) || '0';
+    return ['-' + code, Blockly.bash.ORDER_UNARY_SIGN];
   }
-  Blockly.Python.definitions_['import_math'] = 'import math';
+  Blockly.bash.definitions_['import_math'] = 'import math';
   if (operator == 'SIN' || operator == 'COS' || operator == 'TAN') {
-    arg = Blockly.Python.valueToCode(block, 'NUM',
-        Blockly.Python.ORDER_MULTIPLICATIVE) || '0';
+    arg = Blockly.bash.valueToCode(block, 'NUM',
+        Blockly.bash.ORDER_MULTIPLICATIVE) || '0';
   } else {
-    arg = Blockly.Python.valueToCode(block, 'NUM',
-        Blockly.Python.ORDER_NONE) || '0';
+    arg = Blockly.bash.valueToCode(block, 'NUM',
+        Blockly.bash.ORDER_NONE) || '0';
   }
   // First, handle cases which generate values that don't need parentheses
   // wrapping the code.
@@ -132,7 +132,7 @@ Blockly.Python['math_single'] = function(block) {
       break;
   }
   if (code) {
-    return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+    return [code, Blockly.bash.ORDER_FUNCTION_CALL];
   }
   // Second, handle cases which generate values that may need parentheses
   // wrapping the code.
@@ -149,41 +149,41 @@ Blockly.Python['math_single'] = function(block) {
     default:
       throw 'Unknown math operator: ' + operator;
   }
-  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];
+  return [code, Blockly.bash.ORDER_MULTIPLICATIVE];
 };
 
-Blockly.Python['math_constant'] = function(block) {
+Blockly.bash['math_constant'] = function(block) {
   // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.
   var CONSTANTS = {
-    'PI': ['math.pi', Blockly.Python.ORDER_MEMBER],
-    'E': ['math.e', Blockly.Python.ORDER_MEMBER],
+    'PI': ['math.pi', Blockly.bash.ORDER_MEMBER],
+    'E': ['math.e', Blockly.bash.ORDER_MEMBER],
     'GOLDEN_RATIO': ['(1 + math.sqrt(5)) / 2',
-                     Blockly.Python.ORDER_MULTIPLICATIVE],
-    'SQRT2': ['math.sqrt(2)', Blockly.Python.ORDER_MEMBER],
-    'SQRT1_2': ['math.sqrt(1.0 / 2)', Blockly.Python.ORDER_MEMBER],
-    'INFINITY': ['float(\'inf\')', Blockly.Python.ORDER_ATOMIC]
+                     Blockly.bash.ORDER_MULTIPLICATIVE],
+    'SQRT2': ['math.sqrt(2)', Blockly.bash.ORDER_MEMBER],
+    'SQRT1_2': ['math.sqrt(1.0 / 2)', Blockly.bash.ORDER_MEMBER],
+    'INFINITY': ['float(\'inf\')', Blockly.bash.ORDER_ATOMIC]
   };
   var constant = block.getFieldValue('CONSTANT');
   if (constant != 'INFINITY') {
-    Blockly.Python.definitions_['import_math'] = 'import math';
+    Blockly.bash.definitions_['import_math'] = 'import math';
   }
   return CONSTANTS[constant];
 };
 
-Blockly.Python['math_number_property'] = function(block) {
+Blockly.bash['math_number_property'] = function(block) {
   // Check if a number is even, odd, prime, whole, positive, or negative
   // or if it is divisible by certain number. Returns true or false.
-  var number_to_check = Blockly.Python.valueToCode(block, 'NUMBER_TO_CHECK',
-      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';
+  var number_to_check = Blockly.bash.valueToCode(block, 'NUMBER_TO_CHECK',
+      Blockly.bash.ORDER_MULTIPLICATIVE) || '0';
   var dropdown_property = block.getFieldValue('PROPERTY');
   var code;
   if (dropdown_property == 'PRIME') {
-    Blockly.Python.definitions_['import_math'] = 'import math';
-    Blockly.Python.definitions_['from_numbers_import_Number'] =
+    Blockly.bash.definitions_['import_math'] = 'import math';
+    Blockly.bash.definitions_['from_numbers_import_Number'] =
         'from numbers import Number';
-    var functionName = Blockly.Python.provideFunction_(
+    var functionName = Blockly.bash.provideFunction_(
         'math_isPrime',
-        ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(n):',
+        ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(n):',
          '  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods',
          '  # If n is not a number but a string, try parsing it.',
          '  if not isinstance(n, Number):',
@@ -203,7 +203,7 @@ Blockly.Python['math_number_property'] = function(block) {
          '      return False',
          '  return True']);
     code = functionName + '(' + number_to_check + ')';
-    return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+    return [code, Blockly.bash.ORDER_FUNCTION_CALL];
   }
   switch (dropdown_property) {
     case 'EVEN':
@@ -222,40 +222,40 @@ Blockly.Python['math_number_property'] = function(block) {
       code = number_to_check + ' < 0';
       break;
     case 'DIVISIBLE_BY':
-      var divisor = Blockly.Python.valueToCode(block, 'DIVISOR',
-          Blockly.Python.ORDER_MULTIPLICATIVE);
+      var divisor = Blockly.bash.valueToCode(block, 'DIVISOR',
+          Blockly.bash.ORDER_MULTIPLICATIVE);
       // If 'divisor' is some code that evals to 0, Python will raise an error.
       if (!divisor || divisor == '0') {
-        return ['False', Blockly.Python.ORDER_ATOMIC];
+        return ['False', Blockly.bash.ORDER_ATOMIC];
       }
       code = number_to_check + ' % ' + divisor + ' == 0';
       break;
   }
-  return [code, Blockly.Python.ORDER_RELATIONAL];
+  return [code, Blockly.bash.ORDER_RELATIONAL];
 };
 
-Blockly.Python['math_change'] = function(block) {
+Blockly.bash['math_change'] = function(block) {
   // Add to a variable in place.
-  Blockly.Python.definitions_['from_numbers_import_Number'] =
+  Blockly.bash.definitions_['from_numbers_import_Number'] =
       'from numbers import Number';
-  var argument0 = Blockly.Python.valueToCode(block, 'DELTA',
-      Blockly.Python.ORDER_ADDITIVE) || '0';
-  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
+  var argument0 = Blockly.bash.valueToCode(block, 'DELTA',
+      Blockly.bash.ORDER_ADDITIVE) || '0';
+  var varName = Blockly.bash.variableDB_.getName(block.getFieldValue('VAR'),
       Blockly.Variables.NAME_TYPE);
   return varName + ' = (' + varName + ' if isinstance(' + varName +
       ', Number) else 0) + ' + argument0 + '\n';
 };
 
 // Rounding functions have a single operand.
-Blockly.Python['math_round'] = Blockly.Python['math_single'];
+Blockly.bash['math_round'] = Blockly.bash['math_single'];
 // Trigonometry functions have a single operand.
-Blockly.Python['math_trig'] = Blockly.Python['math_single'];
+Blockly.bash['math_trig'] = Blockly.bash['math_single'];
 
-Blockly.Python['math_on_list'] = function(block) {
+Blockly.bash['math_on_list'] = function(block) {
   // Math functions for lists.
   var func = block.getFieldValue('OP');
-  var list = Blockly.Python.valueToCode(block, 'LIST',
-      Blockly.Python.ORDER_NONE) || '[]';
+  var list = Blockly.bash.valueToCode(block, 'LIST',
+      Blockly.bash.ORDER_NONE) || '[]';
   var code;
   switch (func) {
     case 'SUM':
@@ -268,26 +268,26 @@ Blockly.Python['math_on_list'] = function(block) {
       code = 'max(' + list + ')';
       break;
     case 'AVERAGE':
-      Blockly.Python.definitions_['from_numbers_import_Number'] =
+      Blockly.bash.definitions_['from_numbers_import_Number'] =
           'from numbers import Number';
-      var functionName = Blockly.Python.provideFunction_(
+      var functionName = Blockly.bash.provideFunction_(
           'math_mean',
           // This operation excludes null and values that aren't int or float:',
           // math_mean([null, null, "aString", 1, 9]) == 5.0.',
-          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
+          ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
            '  localList = [e for e in myList if isinstance(e, Number)]',
            '  if not localList: return',
            '  return float(sum(localList)) / len(localList)']);
       code = functionName + '(' + list + ')';
       break;
     case 'MEDIAN':
-      Blockly.Python.definitions_['from_numbers_import_Number'] =
+      Blockly.bash.definitions_['from_numbers_import_Number'] =
           'from numbers import Number';
-      var functionName = Blockly.Python.provideFunction_(
+      var functionName = Blockly.bash.provideFunction_(
           'math_median',
           // This operation excludes null values:
           // math_median([null, null, 1, 3]) == 2.0.
-          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
+          ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
            '  localList = sorted([e for e in myList if isinstance(e, Number)])',
            '  if not localList: return',
            '  if len(localList) % 2 == 0:',
@@ -298,12 +298,12 @@ Blockly.Python['math_on_list'] = function(block) {
       code = functionName + '(' + list + ')';
       break;
     case 'MODE':
-      var functionName = Blockly.Python.provideFunction_(
+      var functionName = Blockly.bash.provideFunction_(
           'math_modes',
           // As a list of numbers can contain more than one mode,
           // the returned result is provided as an array.
           // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].
-          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(some_list):',
+          ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(some_list):',
            '  modes = []',
            '  # Using a lists of [item, count] to keep count rather than dict',
            '  # to avoid "unhashable" errors when the counted item is ' +
@@ -326,10 +326,10 @@ Blockly.Python['math_on_list'] = function(block) {
       code = functionName + '(' + list + ')';
       break;
     case 'STD_DEV':
-      Blockly.Python.definitions_['import_math'] = 'import math';
-      var functionName = Blockly.Python.provideFunction_(
+      Blockly.bash.definitions_['import_math'] = 'import math';
+      var functionName = Blockly.bash.provideFunction_(
           'math_standard_deviation',
-          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(numbers):',
+          ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(numbers):',
            '  n = len(numbers)',
            '  if n == 0: return',
            '  mean = float(sum(numbers)) / n',
@@ -338,51 +338,51 @@ Blockly.Python['math_on_list'] = function(block) {
       code = functionName + '(' + list + ')';
       break;
     case 'RANDOM':
-      Blockly.Python.definitions_['import_random'] = 'import random';
+      Blockly.bash.definitions_['import_random'] = 'import random';
       code = 'random.choice(' + list + ')';
       break;
     default:
       throw 'Unknown operator: ' + func;
   }
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['math_modulo'] = function(block) {
+Blockly.bash['math_modulo'] = function(block) {
   // Remainder computation.
-  var argument0 = Blockly.Python.valueToCode(block, 'DIVIDEND',
-      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'DIVISOR',
-      Blockly.Python.ORDER_MULTIPLICATIVE) || '0';
+  var argument0 = Blockly.bash.valueToCode(block, 'DIVIDEND',
+      Blockly.bash.ORDER_MULTIPLICATIVE) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'DIVISOR',
+      Blockly.bash.ORDER_MULTIPLICATIVE) || '0';
   var code = argument0 + ' % ' + argument1;
-  return [code, Blockly.Python.ORDER_MULTIPLICATIVE];
+  return [code, Blockly.bash.ORDER_MULTIPLICATIVE];
 };
 
-Blockly.Python['math_constrain'] = function(block) {
+Blockly.bash['math_constrain'] = function(block) {
   // Constrain a number between two limits.
-  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'LOW',
-      Blockly.Python.ORDER_NONE) || '0';
-  var argument2 = Blockly.Python.valueToCode(block, 'HIGH',
-      Blockly.Python.ORDER_NONE) || 'float(\'inf\')';
+  var argument0 = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'LOW',
+      Blockly.bash.ORDER_NONE) || '0';
+  var argument2 = Blockly.bash.valueToCode(block, 'HIGH',
+      Blockly.bash.ORDER_NONE) || 'float(\'inf\')';
   var code = 'min(max(' + argument0 + ', ' + argument1 + '), ' +
       argument2 + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['math_random_int'] = function(block) {
+Blockly.bash['math_random_int'] = function(block) {
   // Random integer between [X] and [Y].
-  Blockly.Python.definitions_['import_random'] = 'import random';
-  var argument0 = Blockly.Python.valueToCode(block, 'FROM',
-      Blockly.Python.ORDER_NONE) || '0';
-  var argument1 = Blockly.Python.valueToCode(block, 'TO',
-      Blockly.Python.ORDER_NONE) || '0';
+  Blockly.bash.definitions_['import_random'] = 'import random';
+  var argument0 = Blockly.bash.valueToCode(block, 'FROM',
+      Blockly.bash.ORDER_NONE) || '0';
+  var argument1 = Blockly.bash.valueToCode(block, 'TO',
+      Blockly.bash.ORDER_NONE) || '0';
   var code = 'random.randint(' + argument0 + ', ' + argument1 + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['math_random_float'] = function(block) {
+Blockly.bash['math_random_float'] = function(block) {
   // Random fraction between 0 and 1.
-  Blockly.Python.definitions_['import_random'] = 'import random';
-  return ['random.random()', Blockly.Python.ORDER_FUNCTION_CALL];
+  Blockly.bash.definitions_['import_random'] = 'import random';
+  return ['random.random()', Blockly.bash.ORDER_FUNCTION_CALL];
 };
diff --git a/generators/bash/procedures.js b/generators/bash/procedures.js
index 520b3f5..205d03a 100644
--- a/generators/bash/procedures.js
+++ b/generators/bash/procedures.js
@@ -24,12 +24,12 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.procedures');
+goog.provide('Blockly.bash.procedures');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['procedures_defreturn'] = function(block) {
+Blockly.bash['procedures_defreturn'] = function(block) {
   // Define a procedure with a return value.
   // First, add a 'global' statement for every variable that is not shadowed by
   // a local parameter.
@@ -40,94 +40,94 @@ Blockly.Python['procedures_defreturn'] = function(block) {
   for (var i = 0, variable; variable = variables[i]; i++) {
     varName = variable.name;
     if (block.arguments_.indexOf(varName) == -1) {
-      globals.push(Blockly.Python.variableDB_.getName(varName,
+      globals.push(Blockly.bash.variableDB_.getName(varName,
           Blockly.Variables.NAME_TYPE));
     }
   }
   // Add developer variables.
   var devVarList = Blockly.Variables.allDeveloperVariables(workspace);
   for (var i = 0; i < devVarList.length; i++) {
-    globals.push(Blockly.Python.variableDB_.getName(devVarList[i],
+    globals.push(Blockly.bash.variableDB_.getName(devVarList[i],
         Blockly.Names.DEVELOPER_VARIABLE_TYPE));
   }
 
   globals = globals.length ?
-      Blockly.Python.INDENT + 'global ' + globals.join(', ') + '\n' : '';
-  var funcName = Blockly.Python.variableDB_.getName(
+      Blockly.bash.INDENT + 'global ' + globals.join(', ') + '\n' : '';
+  var funcName = Blockly.bash.variableDB_.getName(
       block.getFieldValue('NAME'), Blockly.Procedures.NAME_TYPE);
-  var branch = Blockly.Python.statementToCode(block, 'STACK');
-  if (Blockly.Python.STATEMENT_PREFIX) {
+  var branch = Blockly.bash.statementToCode(block, 'STACK');
+  if (Blockly.bash.STATEMENT_PREFIX) {
     var id = block.id.replace(/\$/g, '$$$$');  // Issue 251.
-    branch = Blockly.Python.prefixLines(
-        Blockly.Python.STATEMENT_PREFIX.replace(
-            /%1/g, '\'' + id + '\''), Blockly.Python.INDENT) + branch;
+    branch = Blockly.bash.prefixLines(
+        Blockly.bash.STATEMENT_PREFIX.replace(
+            /%1/g, '\'' + id + '\''), Blockly.bash.INDENT) + branch;
   }
-  if (Blockly.Python.INFINITE_LOOP_TRAP) {
-    branch = Blockly.Python.INFINITE_LOOP_TRAP.replace(/%1/g,
+  if (Blockly.bash.INFINITE_LOOP_TRAP) {
+    branch = Blockly.bash.INFINITE_LOOP_TRAP.replace(/%1/g,
         '"' + block.id + '"') + branch;
   }
-  var returnValue = Blockly.Python.valueToCode(block, 'RETURN',
-      Blockly.Python.ORDER_NONE) || '';
+  var returnValue = Blockly.bash.valueToCode(block, 'RETURN',
+      Blockly.bash.ORDER_NONE) || '';
   if (returnValue) {
-    returnValue = Blockly.Python.INDENT + 'return ' + returnValue + '\n';
+    returnValue = Blockly.bash.INDENT + 'return ' + returnValue + '\n';
   } else if (!branch) {
-    branch = Blockly.Python.PASS;
+    branch = Blockly.bash.PASS;
   }
   var args = [];
   for (var i = 0; i < block.arguments_.length; i++) {
-    args[i] = Blockly.Python.variableDB_.getName(block.arguments_[i],
+    args[i] = Blockly.bash.variableDB_.getName(block.arguments_[i],
         Blockly.Variables.NAME_TYPE);
   }
   var code = 'def ' + funcName + '(' + args.join(', ') + '):\n' +
       globals + branch + returnValue;
-  code = Blockly.Python.scrub_(block, code);
+  code = Blockly.bash.scrub_(block, code);
   // Add % so as not to collide with helper functions in definitions list.
-  Blockly.Python.definitions_['%' + funcName] = code;
+  Blockly.bash.definitions_['%' + funcName] = code;
   return null;
 };
 
 // Defining a procedure without a return value uses the same generator as
 // a procedure with a return value.
-Blockly.Python['procedures_defnoreturn'] =
-    Blockly.Python['procedures_defreturn'];
+Blockly.bash['procedures_defnoreturn'] =
+    Blockly.bash['procedures_defreturn'];
 
-Blockly.Python['procedures_callreturn'] = function(block) {
+Blockly.bash['procedures_callreturn'] = function(block) {
   // Call a procedure with a return value.
-  var funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'),
+  var funcName = Blockly.bash.variableDB_.getName(block.getFieldValue('NAME'),
       Blockly.Procedures.NAME_TYPE);
   var args = [];
   for (var i = 0; i < block.arguments_.length; i++) {
-    args[i] = Blockly.Python.valueToCode(block, 'ARG' + i,
-        Blockly.Python.ORDER_NONE) || 'None';
+    args[i] = Blockly.bash.valueToCode(block, 'ARG' + i,
+        Blockly.bash.ORDER_NONE) || 'None';
   }
   var code = funcName + '(' + args.join(', ') + ')';
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['procedures_callnoreturn'] = function(block) {
+Blockly.bash['procedures_callnoreturn'] = function(block) {
   // Call a procedure with no return value.
-  var funcName = Blockly.Python.variableDB_.getName(block.getFieldValue('NAME'),
+  var funcName = Blockly.bash.variableDB_.getName(block.getFieldValue('NAME'),
       Blockly.Procedures.NAME_TYPE);
   var args = [];
   for (var i = 0; i < block.arguments_.length; i++) {
-    args[i] = Blockly.Python.valueToCode(block, 'ARG' + i,
-        Blockly.Python.ORDER_NONE) || 'None';
+    args[i] = Blockly.bash.valueToCode(block, 'ARG' + i,
+        Blockly.bash.ORDER_NONE) || 'None';
   }
   var code = funcName + '(' + args.join(', ') + ')\n';
   return code;
 };
 
-Blockly.Python['procedures_ifreturn'] = function(block) {
+Blockly.bash['procedures_ifreturn'] = function(block) {
   // Conditionally return value from a procedure.
-  var condition = Blockly.Python.valueToCode(block, 'CONDITION',
-      Blockly.Python.ORDER_NONE) || 'False';
+  var condition = Blockly.bash.valueToCode(block, 'CONDITION',
+      Blockly.bash.ORDER_NONE) || 'False';
   var code = 'if ' + condition + ':\n';
   if (block.hasReturnValue_) {
-    var value = Blockly.Python.valueToCode(block, 'VALUE',
-        Blockly.Python.ORDER_NONE) || 'None';
-    code += Blockly.Python.INDENT + 'return ' + value + '\n';
+    var value = Blockly.bash.valueToCode(block, 'VALUE',
+        Blockly.bash.ORDER_NONE) || 'None';
+    code += Blockly.bash.INDENT + 'return ' + value + '\n';
   } else {
-    code += Blockly.Python.INDENT + 'return\n';
+    code += Blockly.bash.INDENT + 'return\n';
   }
   return code;
 };
diff --git a/generators/bash/text.js b/generators/bash/text.js
index 0fefc77..1cb6a26 100644
--- a/generators/bash/text.js
+++ b/generators/bash/text.js
@@ -24,140 +24,140 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.texts');
+goog.provide('Blockly.bash.texts');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['text'] = function(block) {
+Blockly.bash['text'] = function(block) {
   // Text value.
-  var code = Blockly.Python.quote_(block.getFieldValue('TEXT'));
-  return [code, Blockly.Python.ORDER_ATOMIC];
+  var code = Blockly.bash.quote_(block.getFieldValue('TEXT'));
+  return [code, Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['text_join'] = function(block) {
+Blockly.bash['text_join'] = function(block) {
   // Create a string made up of any number of elements of any type.
   //Should we allow joining by '-' or ',' or any other characters?
   switch (block.itemCount_) {
     case 0:
-      return ['\'\'', Blockly.Python.ORDER_ATOMIC];
+      return ['\'\'', Blockly.bash.ORDER_ATOMIC];
       break;
     case 1:
-      var element = Blockly.Python.valueToCode(block, 'ADD0',
-              Blockly.Python.ORDER_NONE) || '\'\'';
+      var element = Blockly.bash.valueToCode(block, 'ADD0',
+              Blockly.bash.ORDER_NONE) || '\'\'';
       var code = 'str(' + element + ')';
-      return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+      return [code, Blockly.bash.ORDER_FUNCTION_CALL];
       break;
     case 2:
-      var element0 = Blockly.Python.valueToCode(block, 'ADD0',
-              Blockly.Python.ORDER_NONE) || '\'\'';
-      var element1 = Blockly.Python.valueToCode(block, 'ADD1',
-              Blockly.Python.ORDER_NONE) || '\'\'';
+      var element0 = Blockly.bash.valueToCode(block, 'ADD0',
+              Blockly.bash.ORDER_NONE) || '\'\'';
+      var element1 = Blockly.bash.valueToCode(block, 'ADD1',
+              Blockly.bash.ORDER_NONE) || '\'\'';
       var code = 'str(' + element0 + ') + str(' + element1 + ')';
-      return [code, Blockly.Python.ORDER_ADDITIVE];
+      return [code, Blockly.bash.ORDER_ADDITIVE];
       break;
     default:
       var elements = [];
       for (var i = 0; i < block.itemCount_; i++) {
-        elements[i] = Blockly.Python.valueToCode(block, 'ADD' + i,
-                Blockly.Python.ORDER_NONE) || '\'\'';
+        elements[i] = Blockly.bash.valueToCode(block, 'ADD' + i,
+                Blockly.bash.ORDER_NONE) || '\'\'';
       }
-      var tempVar = Blockly.Python.variableDB_.getDistinctName('x',
+      var tempVar = Blockly.bash.variableDB_.getDistinctName('x',
           Blockly.Variables.NAME_TYPE);
       var code = '\'\'.join([str(' + tempVar + ') for ' + tempVar + ' in [' +
           elements.join(', ') + ']])';
-      return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+      return [code, Blockly.bash.ORDER_FUNCTION_CALL];
   }
 };
 
-Blockly.Python['text_append'] = function(block) {
+Blockly.bash['text_append'] = function(block) {
   // Append to a variable in place.
-  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
+  var varName = Blockly.bash.variableDB_.getName(block.getFieldValue('VAR'),
       Blockly.Variables.NAME_TYPE);
-  var value = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+  var value = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   return varName + ' = str(' + varName + ') + str(' + value + ')\n';
 };
 
-Blockly.Python['text_length'] = function(block) {
+Blockly.bash['text_length'] = function(block) {
   // Is the string null or array empty?
-  var text = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '\'\'';
-  return ['len(' + text + ')', Blockly.Python.ORDER_FUNCTION_CALL];
+  var text = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '\'\'';
+  return ['len(' + text + ')', Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['text_isEmpty'] = function(block) {
+Blockly.bash['text_isEmpty'] = function(block) {
   // Is the string null or array empty?
-  var text = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   var code = 'not len(' + text + ')';
-  return [code, Blockly.Python.ORDER_LOGICAL_NOT];
+  return [code, Blockly.bash.ORDER_LOGICAL_NOT];
 };
 
-Blockly.Python['text_indexOf'] = function(block) {
+Blockly.bash['text_indexOf'] = function(block) {
   // Search the text for a substring.
   // Should we allow for non-case sensitive???
   var operator = block.getFieldValue('END') == 'FIRST' ? 'find' : 'rfind';
-  var substring = Blockly.Python.valueToCode(block, 'FIND',
-      Blockly.Python.ORDER_NONE) || '\'\'';
-  var text = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+  var substring = Blockly.bash.valueToCode(block, 'FIND',
+      Blockly.bash.ORDER_NONE) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   var code = text + '.' + operator + '(' + substring + ')';
   if (block.workspace.options.oneBasedIndex) {
-    return [code + ' + 1', Blockly.Python.ORDER_ADDITIVE];
+    return [code + ' + 1', Blockly.bash.ORDER_ADDITIVE];
   }
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['text_charAt'] = function(block) {
+Blockly.bash['text_charAt'] = function(block) {
   // Get letter at index.
   // Note: Until January 2013 this block did not have the WHERE input.
   var where = block.getFieldValue('WHERE') || 'FROM_START';
-  var text = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   switch (where) {
     case 'FIRST':
       var code = text + '[0]';
-      return [code, Blockly.Python.ORDER_MEMBER];
+      return [code, Blockly.bash.ORDER_MEMBER];
     case 'LAST':
       var code = text + '[-1]';
-      return [code, Blockly.Python.ORDER_MEMBER];
+      return [code, Blockly.bash.ORDER_MEMBER];
     case 'FROM_START':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT');
+      var at = Blockly.bash.getAdjustedInt(block, 'AT');
       var code = text + '[' + at + ']';
-      return [code, Blockly.Python.ORDER_MEMBER];
+      return [code, Blockly.bash.ORDER_MEMBER];
     case 'FROM_END':
-      var at = Blockly.Python.getAdjustedInt(block, 'AT', 1, true);
+      var at = Blockly.bash.getAdjustedInt(block, 'AT', 1, true);
       var code = text + '[' + at + ']';
-      return [code, Blockly.Python.ORDER_MEMBER];
+      return [code, Blockly.bash.ORDER_MEMBER];
     case 'RANDOM':
-      Blockly.Python.definitions_['import_random'] = 'import random';
-      var functionName = Blockly.Python.provideFunction_(
+      Blockly.bash.definitions_['import_random'] = 'import random';
+      var functionName = Blockly.bash.provideFunction_(
           'text_random_letter',
-          ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(text):',
+          ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(text):',
            '  x = int(random.random() * len(text))',
            '  return text[x];']);
       code = functionName + '(' + text + ')';
-      return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+      return [code, Blockly.bash.ORDER_FUNCTION_CALL];
   }
   throw 'Unhandled option (text_charAt).';
 };
 
-Blockly.Python['text_getSubstring'] = function(block) {
+Blockly.bash['text_getSubstring'] = function(block) {
   // Get substring.
   var where1 = block.getFieldValue('WHERE1');
   var where2 = block.getFieldValue('WHERE2');
-  var text = Blockly.Python.valueToCode(block, 'STRING',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'STRING',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   switch (where1) {
     case 'FROM_START':
-      var at1 = Blockly.Python.getAdjustedInt(block, 'AT1');
+      var at1 = Blockly.bash.getAdjustedInt(block, 'AT1');
       if (at1 == '0') {
         at1 = '';
       }
       break;
     case 'FROM_END':
-      var at1 = Blockly.Python.getAdjustedInt(block, 'AT1', 1, true);
+      var at1 = Blockly.bash.getAdjustedInt(block, 'AT1', 1, true);
       break;
     case 'FIRST':
       var at1 = '';
@@ -167,14 +167,14 @@ Blockly.Python['text_getSubstring'] = function(block) {
   }
   switch (where2) {
     case 'FROM_START':
-      var at2 = Blockly.Python.getAdjustedInt(block, 'AT2', 1);
+      var at2 = Blockly.bash.getAdjustedInt(block, 'AT2', 1);
       break;
     case 'FROM_END':
-      var at2 = Blockly.Python.getAdjustedInt(block, 'AT2', 0, true);
+      var at2 = Blockly.bash.getAdjustedInt(block, 'AT2', 0, true);
       // Ensure that if the result calculated is 0 that sub-sequence will
       // include all elements as expected.
       if (!Blockly.isNumber(String(at2))) {
-        Blockly.Python.definitions_['import_sys'] = 'import sys';
+        Blockly.bash.definitions_['import_sys'] = 'import sys';
         at2 += ' or sys.maxsize';
       } else if (at2 == '0') {
         at2 = '';
@@ -187,10 +187,10 @@ Blockly.Python['text_getSubstring'] = function(block) {
       throw 'Unhandled option (text_getSubstring)';
   }
   var code = text + '[' + at1 + ' : ' + at2 + ']';
-  return [code, Blockly.Python.ORDER_MEMBER];
+  return [code, Blockly.bash.ORDER_MEMBER];
 };
 
-Blockly.Python['text_changeCase'] = function(block) {
+Blockly.bash['text_changeCase'] = function(block) {
   // Change capitalization.
   var OPERATORS = {
     'UPPERCASE': '.upper()',
@@ -198,13 +198,13 @@ Blockly.Python['text_changeCase'] = function(block) {
     'TITLECASE': '.title()'
   };
   var operator = OPERATORS[block.getFieldValue('CASE')];
-  var text = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   var code = text + operator;
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['text_trim'] = function(block) {
+Blockly.bash['text_trim'] = function(block) {
   // Trim spaces.
   var OPERATORS = {
     'LEFT': '.lstrip()',
@@ -212,69 +212,69 @@ Blockly.Python['text_trim'] = function(block) {
     'BOTH': '.strip()'
   };
   var operator = OPERATORS[block.getFieldValue('MODE')];
-  var text = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+  var text = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   var code = text + operator;
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['text_print'] = function(block) {
+Blockly.bash['text_print'] = function(block) {
   // Print statement.
-  var msg = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+  var msg = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   return 'print(' + msg + ')\n';
 };
 
-Blockly.Python['text_prompt_ext'] = function(block) {
+Blockly.bash['text_prompt_ext'] = function(block) {
   // Prompt function.
-  var functionName = Blockly.Python.provideFunction_(
+  var functionName = Blockly.bash.provideFunction_(
       'text_prompt',
-      ['def ' + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + '(msg):',
+      ['def ' + Blockly.bash.FUNCTION_NAME_PLACEHOLDER_ + '(msg):',
        '  try:',
        '    return raw_input(msg)',
        '  except NameError:',
        '    return input(msg)']);
   if (block.getField('TEXT')) {
     // Internal message.
-    var msg = Blockly.Python.quote_(block.getFieldValue('TEXT'));
+    var msg = Blockly.bash.quote_(block.getFieldValue('TEXT'));
   } else {
     // External message.
-    var msg = Blockly.Python.valueToCode(block, 'TEXT',
-        Blockly.Python.ORDER_NONE) || '\'\'';
+    var msg = Blockly.bash.valueToCode(block, 'TEXT',
+        Blockly.bash.ORDER_NONE) || '\'\'';
   }
   var code = functionName + '(' + msg + ')';
   var toNumber = block.getFieldValue('TYPE') == 'NUMBER';
   if (toNumber) {
     code = 'float(' + code + ')';
   }
-  return [code, Blockly.Python.ORDER_FUNCTION_CALL];
+  return [code, Blockly.bash.ORDER_FUNCTION_CALL];
 };
 
-Blockly.Python['text_prompt'] = Blockly.Python['text_prompt_ext'];
+Blockly.bash['text_prompt'] = Blockly.bash['text_prompt_ext'];
 
-Blockly.Python['text_count'] = function(block) {
-  var text = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
-  var sub = Blockly.Python.valueToCode(block, 'SUB',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+Blockly.bash['text_count'] = function(block) {
+  var text = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
+  var sub = Blockly.bash.valueToCode(block, 'SUB',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   var code = text + '.count(' + sub + ')';
-  return [code, Blockly.Python.ORDER_MEMBER];
+  return [code, Blockly.bash.ORDER_MEMBER];
 };
 
-Blockly.Python['text_replace'] = function(block) {
-  var text = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
-  var from = Blockly.Python.valueToCode(block, 'FROM',
-      Blockly.Python.ORDER_NONE) || '\'\'';
-  var to = Blockly.Python.valueToCode(block, 'TO',
-      Blockly.Python.ORDER_NONE) || '\'\'';
+Blockly.bash['text_replace'] = function(block) {
+  var text = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
+  var from = Blockly.bash.valueToCode(block, 'FROM',
+      Blockly.bash.ORDER_NONE) || '\'\'';
+  var to = Blockly.bash.valueToCode(block, 'TO',
+      Blockly.bash.ORDER_NONE) || '\'\'';
   var code = text + '.replace(' + from + ', ' + to + ')';
-  return [code, Blockly.Python.ORDER_MEMBER];
+  return [code, Blockly.bash.ORDER_MEMBER];
 };
 
-Blockly.Python['text_reverse'] = function(block) {
-  var text = Blockly.Python.valueToCode(block, 'TEXT',
-      Blockly.Python.ORDER_MEMBER) || '\'\'';
+Blockly.bash['text_reverse'] = function(block) {
+  var text = Blockly.bash.valueToCode(block, 'TEXT',
+      Blockly.bash.ORDER_MEMBER) || '\'\'';
   var code = text + '[::-1]';
-  return [code, Blockly.Python.ORDER_MEMBER];
+  return [code, Blockly.bash.ORDER_MEMBER];
 };
diff --git a/generators/bash/variables.js b/generators/bash/variables.js
index 00d9971..8dc8e3f 100644
--- a/generators/bash/variables.js
+++ b/generators/bash/variables.js
@@ -24,23 +24,23 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.variables');
+goog.provide('Blockly.bash.variables');
 
-goog.require('Blockly.Python');
+goog.require('Blockly.bash');
 
 
-Blockly.Python['variables_get'] = function(block) {
+Blockly.bash['variables_get'] = function(block) {
   // Variable getter.
-  var code = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
+  var code = Blockly.bash.variableDB_.getName(block.getFieldValue('VAR'),
       Blockly.Variables.NAME_TYPE);
-  return [code, Blockly.Python.ORDER_ATOMIC];
+  return [code, Blockly.bash.ORDER_ATOMIC];
 };
 
-Blockly.Python['variables_set'] = function(block) {
+Blockly.bash['variables_set'] = function(block) {
   // Variable setter.
-  var argument0 = Blockly.Python.valueToCode(block, 'VALUE',
-      Blockly.Python.ORDER_NONE) || '0';
-  var varName = Blockly.Python.variableDB_.getName(block.getFieldValue('VAR'),
+  var argument0 = Blockly.bash.valueToCode(block, 'VALUE',
+      Blockly.bash.ORDER_NONE) || '0';
+  var varName = Blockly.bash.variableDB_.getName(block.getFieldValue('VAR'),
       Blockly.Variables.NAME_TYPE);
   return varName + ' = ' + argument0 + '\n';
 };
diff --git a/generators/bash/variables_dynamic.js b/generators/bash/variables_dynamic.js
index 928421a..7e03ca6 100644
--- a/generators/bash/variables_dynamic.js
+++ b/generators/bash/variables_dynamic.js
@@ -24,12 +24,12 @@
  */
 'use strict';
 
-goog.provide('Blockly.Python.variablesDynamic');
+goog.provide('Blockly.bash.variablesDynamic');
 
-goog.require('Blockly.Python');
-goog.require('Blockly.Python.variables');
+goog.require('Blockly.bash');
+goog.require('Blockly.bash.variables');
 
 
 // Python is dynamically typed.
-Blockly.Python['variables_get_dynamic'] = Blockly.Python['variables_get'];
-Blockly.Python['variables_set_dynamic'] = Blockly.Python['variables_set'];
+Blockly.bash['variables_get_dynamic'] = Blockly.bash['variables_get'];
+Blockly.bash['variables_set_dynamic'] = Blockly.bash['variables_set'];
